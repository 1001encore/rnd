<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RND Explorer</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --bg: #0a0a0a;
            --card: #161616;
            --text: #e0e0e0;
            --accent: #00e676;
            --err: #ff5252;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            padding: 20px;
            margin: 0;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        /* Header */
        h1 {
            margin-bottom: 5px;
            color: var(--accent);
        }

        p {
            color: #888;
            margin-bottom: 25px;
            font-size: 0.9rem;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            background: var(--card);
            padding: 15px;
            border-radius: 8px;
            flex-wrap: wrap;
            border: 1px solid #333;
        }

        input,
        select {
            padding: 10px;
            background: #222;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            flex-grow: 1;
            min-width: 120px;
        }

        button {
            padding: 10px 20px;
            background: var(--accent);
            color: black;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: opacity 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        /* Chart Area */
        #chart {
            width: 100%;
            height: 600px;
            background: var(--card);
            margin-top: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            position: relative;
        }

        /* Center the status text before chart loads */
        #chart .status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Make Plotly chart fill the container */
        #chart .js-plotly-plot,
        #chart .plotly,
        #chart .plot-container {
            width: 100% !important;
            height: 100% !important;
        }

        .status {
            position: absolute;
            color: #666;
            font-size: 1.1rem;
        }

        .error {
            color: var(--err);
            background: rgba(255, 82, 82, 0.1);
            padding: 10px;
            border-radius: 4px;
            margin-top: 20px;
            display: none;
            border: 1px solid var(--err);
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>RND Explorer</h1>
        <p>Risk-Neutral Density Estimator (Pure JS + Cloudflare)</p>

        <div class="controls">
            <input type="text" id="ticker" value="SPY" placeholder="Ticker (e.g. SPY)">
            <button onclick="loadExpirations()" id="btn-load">1. Load Dates</button>
            <select id="expiry" disabled>
                <option>Select Date...</option>
            </select>
            <button onclick="calculateRND()" id="btn-calc" disabled>2. Calculate PDF</button>
        </div>

        <div id="error-box" class="error"></div>

        <div id="chart">
            <div class="status" id="status-text">Enter a ticker to begin</div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const API_URL = "https://rnd.1001encore.workers.dev";

        // --- MATH UTILS (B-Spline Smoothing) ---

        // Cubic B-spline basis function
        function bsplineBasis(i, k, t, knots) {
            if (k === 0) {
                return (t >= knots[i] && t < knots[i + 1]) ? 1 : 0;
            }

            let left = 0, right = 0;
            const denom1 = knots[i + k] - knots[i];
            const denom2 = knots[i + k + 1] - knots[i + 1];

            if (denom1 !== 0) {
                left = ((t - knots[i]) / denom1) * bsplineBasis(i, k - 1, t, knots);
            }
            if (denom2 !== 0) {
                right = ((knots[i + k + 1] - t) / denom2) * bsplineBasis(i + 1, k - 1, t, knots);
            }

            return left + right;
        }

        // Generate uniform knots for B-spline
        function generateKnots(n, degree) {
            const knots = [];
            const m = n + degree + 1;
            for (let i = 0; i < m; i++) {
                if (i <= degree) {
                    knots.push(0);
                } else if (i >= m - degree - 1) {
                    knots.push(1);
                } else {
                    knots.push((i - degree) / (n - degree));
                }
            }
            return knots;
        }

        // Fit B-spline to data points using least squares
        function fitBSpline(x, y, numControlPoints = 20, degree = 3) {
            const n = numControlPoints;
            const minX = Math.min(...x);
            const maxX = Math.max(...x);

            // Normalize x to [0, 1]
            const tValues = x.map(xi => (xi - minX) / (maxX - minX));

            const knots = generateKnots(n, degree);

            // Build basis matrix
            const B = [];
            for (let j = 0; j < x.length; j++) {
                const row = [];
                const t = Math.min(0.9999, Math.max(0, tValues[j])); // Clamp to avoid boundary issues
                for (let i = 0; i < n; i++) {
                    row.push(bsplineBasis(i, degree, t, knots));
                }
                B.push(row);
            }

            // Solve least squares: (B^T B) c = B^T y
            // Using simple pseudo-inverse approximation
            const BtB = [];
            const Bty = [];

            for (let i = 0; i < n; i++) {
                BtB.push(new Array(n).fill(0));
                Bty.push(0);
                for (let j = 0; j < x.length; j++) {
                    Bty[i] += B[j][i] * y[j];
                    for (let k = 0; k < n; k++) {
                        BtB[i][k] += B[j][i] * B[j][k];
                    }
                }
                // Add regularization to avoid singular matrix
                BtB[i][i] += 0.001;
            }

            // Solve using Gauss-Seidel iteration
            const controlPoints = new Array(n).fill(0);
            for (let iter = 0; iter < 100; iter++) {
                for (let i = 0; i < n; i++) {
                    let sum = Bty[i];
                    for (let j = 0; j < n; j++) {
                        if (i !== j) sum -= BtB[i][j] * controlPoints[j];
                    }
                    controlPoints[i] = sum / BtB[i][i];
                }
            }

            return { controlPoints, knots, degree, minX, maxX };
        }

        // Evaluate B-spline at given x values
        function evaluateBSpline(spline, xValues) {
            const { controlPoints, knots, degree, minX, maxX } = spline;
            const n = controlPoints.length;

            return xValues.map(x => {
                // Normalize and clamp
                let t = (x - minX) / (maxX - minX);
                t = Math.min(0.9999, Math.max(0.0001, t));

                let val = 0;
                for (let i = 0; i < n; i++) {
                    val += controlPoints[i] * bsplineBasis(i, degree, t, knots);
                }
                return val;
            });
        }

        // Compute second derivative of B-spline (for RND)
        function bsplineSecondDerivative(spline, xValues, h = null) {
            const { minX, maxX } = spline;
            if (h === null) {
                h = (maxX - minX) / 500; // Small step for numerical derivative
            }

            return xValues.map(x => {
                const yMinus = evaluateBSpline(spline, [x - h])[0];
                const yCenter = evaluateBSpline(spline, [x])[0];
                const yPlus = evaluateBSpline(spline, [x + h])[0];
                return (yPlus - 2 * yCenter + yMinus) / (h * h);
            });
        }

        // Remove outliers using IQR method
        function removeOutliers(data, key, factor = 1.5) {
            const values = data.map(d => d[key]).sort((a, b) => a - b);
            const q1 = values[Math.floor(values.length * 0.25)];
            const q3 = values[Math.floor(values.length * 0.75)];
            const iqr = q3 - q1;
            const lower = q1 - factor * iqr;
            const upper = q3 + factor * iqr;
            return data.filter(d => d[key] >= lower && d[key] <= upper);
        }

        // Gaussian smoothing for final PDF polish
        function gaussianSmooth(x, y, sigma) {
            const smoothed = [];
            for (let i = 0; i < x.length; i++) {
                let num = 0, den = 0;
                for (let j = 0; j < x.length; j++) {
                    const w = Math.exp(-Math.pow(x[i] - x[j], 2) / (2 * sigma * sigma));
                    num += w * y[j];
                    den += w;
                }
                smoothed.push(num / den);
            }
            return smoothed;
        }

        // --- UI LOGIC ---
        const ui = {
            ticker: document.getElementById("ticker"),
            loadBtn: document.getElementById("btn-load"),
            calcBtn: document.getElementById("btn-calc"),
            select: document.getElementById("expiry"),
            chart: document.getElementById("chart"),
            status: document.getElementById("status-text"),
            err: document.getElementById("error-box")
        };

        function showError(msg) {
            ui.err.style.display = 'block';
            ui.err.innerText = "Error: " + msg;
            ui.status.innerText = "";
        }

        async function loadExpirations() {
            ui.err.style.display = 'none';
            ui.loadBtn.innerText = "Loading...";

            try {
                const res = await fetch(`${API_URL}/?ticker=${ui.ticker.value}`);
                const data = await res.json();

                if (data.error) throw new Error(data.details || "API Error");
                if (!data.optionChain) throw new Error("No option data found");

                const dates = data.optionChain.result[0].expirationDates;
                ui.select.innerHTML = "";

                dates.forEach(ts => {
                    const d = new Date(ts * 1000);
                    const opt = document.createElement("option");
                    opt.value = ts;
                    opt.text = d.toISOString().split('T')[0];
                    ui.select.appendChild(opt);
                });

                ui.select.disabled = false;
                ui.calcBtn.disabled = false;
                ui.loadBtn.innerText = "1. Load Dates";
                ui.status.innerText = "Date Loaded. Click Calculate.";

            } catch (e) {
                showError(e.message);
                ui.loadBtn.innerText = "Retry";
            }
        }

        async function calculateRND() {
            ui.calcBtn.innerText = "Calculating...";
            ui.status.innerText = "Fetching Option Chain...";
            ui.chart.innerHTML = ""; // Clear chart

            try {
                const ticker = ui.ticker.value;
                const date = ui.select.value;

                // 1. Fetch Data
                const res = await fetch(`${API_URL}/?ticker=${ticker}&date=${date}`);
                const json = await res.json();

                if (json.error) throw new Error(json.details);

                const result = json.optionChain.result[0];
                const calls = result.options[0].calls;
                const currentPrice = result.quote.regularMarketPrice;

                // 2. Process Data with balanced filtering
                // Filter for reasonably liquid options, but not too aggressive
                let data = calls
                    .filter(c => {
                        // Must have some volume OR open interest (relaxed)
                        if ((!c.volume || c.volume < 1) && (!c.openInterest || c.openInterest < 5)) return false;

                        // Must have valid bid/ask
                        if (!c.bid || c.bid < 0.01) return false;
                        if (!c.ask || c.ask <= c.bid) return false;

                        // Bid-ask spread should be reasonable (< 80% of mid) - relaxed
                        const mid = (c.bid + c.ask) / 2;
                        const spread = c.ask - c.bid;
                        if (spread / mid > 0.8) return false;

                        // Moneyness filter: wider range to include tails
                        // 50% to 150% of current price (relaxed from 70-130%)
                        const moneyness = c.strike / currentPrice;
                        if (moneyness < 0.50 || moneyness > 1.50) return false;

                        return true;
                    })
                    .map(c => ({
                        k: c.strike,
                        p: (c.bid + c.ask) / 2,
                        vol: c.volume,
                        oi: c.openInterest
                    }))
                    .sort((a, b) => a.k - b.k);

                // Remove price outliers
                data = removeOutliers(data, 'p', 2.0);

                if (data.length < 10) throw new Error("Not enough liquid options to calculate RND. Try a different expiration.");

                const strikes = data.map(d => d.k);
                const prices = data.map(d => d.p);

                // 3. Fit B-spline to call prices
                // Use more control points for better fit, fewer for smoother curve
                const numControlPoints = Math.min(25, Math.max(12, Math.floor(data.length / 3)));
                const spline = fitBSpline(strikes, prices, numControlPoints, 3);

                // Generate evaluation points (extend slightly beyond data range for smooth tails)
                const minK = Math.min(...strikes);
                const maxK = Math.max(...strikes);
                const range = maxK - minK;
                const evalMin = minK - range * 0.05; // Extend 5% on each side
                const evalMax = maxK + range * 0.05;
                const numEvalPoints = 200;

                const evalStrikes = [];
                for (let i = 0; i < numEvalPoints; i++) {
                    evalStrikes.push(evalMin + (evalMax - evalMin) * i / (numEvalPoints - 1));
                }

                // Compute second derivative (the RND/PDF)
                let pdfY = bsplineSecondDerivative(spline, evalStrikes);

                // Light Gaussian smoothing on the PDF for extra polish
                const sigma = (maxK - minK) / 30;
                pdfY = gaussianSmooth(evalStrikes, pdfY, sigma);

                // Clip negatives
                pdfY = pdfY.map(y => Math.max(0, y));

                // Normalize PDF (trapezoid rule)
                let area = 0;
                for (let i = 1; i < evalStrikes.length; i++) {
                    area += (pdfY[i] + pdfY[i - 1]) / 2 * (evalStrikes[i] - evalStrikes[i - 1]);
                }
                const finalPDF = area > 0 ? pdfY.map(y => y / area) : pdfY;

                // 4. Plot
                Plotly.newPlot('chart', [{
                    x: evalStrikes, y: finalPDF,
                    mode: 'lines', fill: 'tozeroy',
                    line: { color: '#00e676', width: 3 },
                    name: 'Implied Probability'
                }], {
                    title: `RND: ${ticker} (${new Date(date * 1000).toLocaleDateString()})`,
                    paper_bgcolor: '#161616', plot_bgcolor: '#161616',
                    font: { color: '#e0e0e0' },
                    xaxis: { title: 'Strike Price ($)', gridcolor: '#333' },
                    yaxis: { title: 'Probability Density', gridcolor: '#333' },
                    shapes: [{ type: 'line', x0: currentPrice, x1: currentPrice, y0: 0, y1: Math.max(...finalPDF), line: { color: 'white', dash: 'dot' } }],
                    autosize: true,
                    margin: { l: 60, r: 30, t: 50, b: 50 }
                }, { responsive: true });

                ui.calcBtn.innerText = "2. Calculate PDF";

            } catch (e) {
                showError(e.message);
                ui.calcBtn.innerText = "Retry";
            }
        }
    </script>

</body>

</html>