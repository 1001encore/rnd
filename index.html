<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RND Explorer</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --bg: #0a0a0a;
            --card: #161616;
            --text: #e0e0e0;
            --accent: #00e676;
            --err: #ff5252;
            --panel-width: 220px;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            padding: 0;
            margin: 0;
        }

        .app-layout {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .app-header {
            padding: 20px 20px 0 20px;
        }

        .main-area {
            display: flex;
            flex: 1;
            padding-top: 20px;
        }

        .content-area {
            flex: 1;
            padding: 0 20px 20px 20px;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        h1 {
            margin-bottom: 5px;
            color: var(--accent);
        }

        p {
            color: #888;
            margin-bottom: 25px;
            font-size: 0.9rem;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            background: var(--card);
            padding: 15px;
            border-radius: 8px;
            flex-wrap: wrap;
            border: 1px solid #333;
        }

        input,
        select {
            padding: 10px;
            background: #222;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            flex-grow: 1;
            min-width: 120px;
        }

        /* Date selector panel */

        .date-panel {
            background: var(--card);
            border: 1px solid #333;
            border-radius: 8px;
            width: var(--panel-width);
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
            margin-left: 20px;
            margin-bottom: 20px;
        }

        .date-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .date-panel-title {
            color: #ccc;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .date-actions {
            display: flex;
            gap: 4px;
        }

        .date-actions button {
            padding: 2px 6px;
            font-size: 0.65rem;
            background: #333;
            color: #aaa;
            border-radius: 3px;
            border: 1px solid #444;
            cursor: pointer;
            flex: 1;
        }

        .date-actions button:hover {
            background: #444;
            color: white;
            border-color: #555;
        }

        .date-checkboxes {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
            padding-right: 4px;
            max-height: 70vh;
            overflow-y: auto;
        }

        /* Custom Scrollbar for panel */
        .date-checkboxes::-webkit-scrollbar {
            width: 6px;
        }

        .date-checkboxes::-webkit-scrollbar-track {
            background: #111;
        }

        .date-checkboxes::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        .date-checkboxes::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        .date-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            cursor: pointer;
            transition: background 0.1s;
            font-size: 0.8rem;
            color: #aaa;
            border-radius: 4px;
        }

        .date-checkbox:hover {
            background: #222;
            color: #fff;
        }

        .date-checkbox.selected {
            background: rgba(0, 230, 118, 0.15);
            color: var(--accent);
            font-weight: 500;
        }

        .date-checkbox input {
            accent-color: var(--accent);
            width: 13px;
            height: 13px;
            cursor: pointer;
            margin: 0;
            flex-shrink: 0;
        }

        .date-checkbox label {
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .empty-state {
            color: #444;
            font-size: 0.8rem;
            text-align: center;
            margin-top: 20px;
            font-style: italic;
        }

        .date-checkbox label {
            cursor: pointer;
            user-select: none;
        }



        button {
            padding: 10px 20px;
            background: var(--accent);
            color: black;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: opacity 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        /* Chart Area */
        #chart {
            width: 100%;
            height: calc(100vh - 200px);
            /* Fill remaining height roughly */
            min-height: 500px;
            background: var(--card);
            margin-top: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            position: relative;
        }

        /* Center the status text before chart loads */
        #chart .status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Make Plotly chart fill the container */
        #chart .js-plotly-plot,
        #chart .plotly,
        #chart .plot-container {
            width: 100% !important;
            height: 100% !important;
        }

        .status {
            position: absolute;
            color: #666;
            font-size: 1.1rem;
        }

        .error {
            color: var(--err);
            background: rgba(255, 82, 82, 0.1);
            padding: 10px;
            border-radius: 4px;
            margin-top: 20px;
            display: none;
            border: 1px solid var(--err);
        }
    </style>
</head>

<body>

    <div class="app-layout">
        <div class="app-header">
            <h1>Risk-Neutral Density (RND) Visualizer</h1>
        </div>

        <div class="main-area">
            <div id="date-panel" class="date-panel">
                <div class="date-panel-header">
                    <span class="date-panel-title">Expirations</span>
                    <div class="date-actions">
                        <button onclick="selectAllDates()" title="Select All">All</button>
                        <button onclick="clearAllDates()" title="Clear All">None</button>
                    </div>
                </div>
                <div id="date-checkboxes" class="date-checkboxes">
                    <div class="empty-state">Load dates first</div>
                </div>
            </div>

            <div class="content-area">
                <div class="controls">
                    <input type="text" id="ticker" value="SPY" placeholder="Ticker (e.g. SPY)">
                    <button onclick="loadExpirations()" id="btn-load">1. Load Dates</button>
                    <button onclick="calculateRND()" id="btn-calc" disabled>2. Calculate & Chart</button>
                </div>

                <div id="error-box" class="error"></div>

                <div id="chart">
                    <div class="status" id="status-text">Enter a ticker to begin</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const API_URL = "https://rnd.1001encore.workers.dev";

        // --- MATH UTILS (B-Spline Smoothing) ---

        // Cubic B-spline basis function
        function bsplineBasis(i, k, t, knots) {
            if (k === 0) {
                return (t >= knots[i] && t < knots[i + 1]) ? 1 : 0;
            }

            let left = 0, right = 0;
            const denom1 = knots[i + k] - knots[i];
            const denom2 = knots[i + k + 1] - knots[i + 1];

            if (denom1 !== 0) {
                left = ((t - knots[i]) / denom1) * bsplineBasis(i, k - 1, t, knots);
            }
            if (denom2 !== 0) {
                right = ((knots[i + k + 1] - t) / denom2) * bsplineBasis(i + 1, k - 1, t, knots);
            }

            return left + right;
        }

        // Generate uniform knots for B-spline
        function generateKnots(n, degree) {
            const knots = [];
            const m = n + degree + 1;
            for (let i = 0; i < m; i++) {
                if (i <= degree) {
                    knots.push(0);
                } else if (i >= m - degree - 1) {
                    knots.push(1);
                } else {
                    knots.push((i - degree) / (n - degree));
                }
            }
            return knots;
        }

        // Fit B-spline to data points using least squares
        function fitBSpline(x, y, numControlPoints = 20, degree = 3) {
            const n = numControlPoints;
            const minX = Math.min(...x);
            const maxX = Math.max(...x);

            // Normalize x to [0, 1]
            const tValues = x.map(xi => (xi - minX) / (maxX - minX));

            const knots = generateKnots(n, degree);

            // Build basis matrix
            const B = [];
            for (let j = 0; j < x.length; j++) {
                const row = [];
                const t = Math.min(0.9999, Math.max(0, tValues[j])); // Clamp to avoid boundary issues
                for (let i = 0; i < n; i++) {
                    row.push(bsplineBasis(i, degree, t, knots));
                }
                B.push(row);
            }

            // Solve least squares: (B^T B) c = B^T y
            // Using simple pseudo-inverse approximation
            const BtB = [];
            const Bty = [];

            for (let i = 0; i < n; i++) {
                BtB.push(new Array(n).fill(0));
                Bty.push(0);
                for (let j = 0; j < x.length; j++) {
                    Bty[i] += B[j][i] * y[j];
                    for (let k = 0; k < n; k++) {
                        BtB[i][k] += B[j][i] * B[j][k];
                    }
                }
                // Add regularization to avoid singular matrix
                BtB[i][i] += 0.001;
            }

            // Solve using Gauss-Seidel iteration
            const controlPoints = new Array(n).fill(0);
            for (let iter = 0; iter < 100; iter++) {
                for (let i = 0; i < n; i++) {
                    let sum = Bty[i];
                    for (let j = 0; j < n; j++) {
                        if (i !== j) sum -= BtB[i][j] * controlPoints[j];
                    }
                    controlPoints[i] = sum / BtB[i][i];
                }
            }

            return { controlPoints, knots, degree, minX, maxX };
        }

        // Evaluate B-spline at given x values
        function evaluateBSpline(spline, xValues) {
            const { controlPoints, knots, degree, minX, maxX } = spline;
            const n = controlPoints.length;

            return xValues.map(x => {
                // Normalize and clamp
                let t = (x - minX) / (maxX - minX);
                t = Math.min(0.9999, Math.max(0.0001, t));

                let val = 0;
                for (let i = 0; i < n; i++) {
                    val += controlPoints[i] * bsplineBasis(i, degree, t, knots);
                }
                return val;
            });
        }

        // Compute second derivative of B-spline (for RND)
        function bsplineSecondDerivative(spline, xValues, h = null) {
            const { minX, maxX } = spline;
            if (h === null) {
                h = (maxX - minX) / 500; // Small step for numerical derivative
            }

            return xValues.map(x => {
                const yMinus = evaluateBSpline(spline, [x - h])[0];
                const yCenter = evaluateBSpline(spline, [x])[0];
                const yPlus = evaluateBSpline(spline, [x + h])[0];
                return (yPlus - 2 * yCenter + yMinus) / (h * h);
            });
        }

        // Remove outliers using IQR method
        function removeOutliers(data, key, factor = 1.5) {
            const values = data.map(d => d[key]).sort((a, b) => a - b);
            const q1 = values[Math.floor(values.length * 0.25)];
            const q3 = values[Math.floor(values.length * 0.75)];
            const iqr = q3 - q1;
            const lower = q1 - factor * iqr;
            const upper = q3 + factor * iqr;
            return data.filter(d => d[key] >= lower && d[key] <= upper);
        }

        // Gaussian smoothing for final PDF polish
        function gaussianSmooth(x, y, sigma) {
            const smoothed = [];
            for (let i = 0; i < x.length; i++) {
                let num = 0, den = 0;
                for (let j = 0; j < x.length; j++) {
                    const w = Math.exp(-Math.pow(x[i] - x[j], 2) / (2 * sigma * sigma));
                    num += w * y[j];
                    den += w;
                }
                smoothed.push(num / den);
            }
            return smoothed;
        }

        // --- UI LOGIC ---
        const ui = {
            ticker: document.getElementById("ticker"),
            loadBtn: document.getElementById("btn-load"),
            calcBtn: document.getElementById("btn-calc"),
            chart: document.getElementById("chart"),
            status: document.getElementById("status-text"),
            err: document.getElementById("error-box"),
            datePanel: document.getElementById("date-panel"),
            dateCheckboxes: document.getElementById("date-checkboxes")
        };

        function showError(msg) {
            ui.err.style.display = 'block';
            ui.err.innerText = "Error: " + msg;
            ui.status.innerText = "";
        }

        function toggleDateCheckbox(container) {
            const checkbox = container.querySelector('input');
            checkbox.checked = !checkbox.checked;
            container.classList.toggle('selected', checkbox.checked);
        }

        function selectAllDates() {
            document.querySelectorAll('.date-checkbox input').forEach(cb => {
                cb.checked = true;
                cb.closest('.date-checkbox').classList.add('selected');
            });
        }

        function clearAllDates() {
            document.querySelectorAll('.date-checkbox input').forEach(cb => {
                cb.checked = false;
                cb.closest('.date-checkbox').classList.remove('selected');
            });
        }

        async function loadExpirations() {
            ui.err.style.display = 'none';
            ui.loadBtn.innerText = "Loading...";

            try {
                const res = await fetch(`${API_URL}/?ticker=${ui.ticker.value}`);
                const data = await res.json();

                if (data.error) throw new Error(data.details || "API Error");
                if (!data.optionChain) throw new Error("No option data found");

                const dates = data.optionChain.result[0].expirationDates;
                ui.dateCheckboxes.innerHTML = "";

                dates.forEach(ts => {
                    const d = new Date(ts * 1000);
                    const dayOfWeek = d.getDay();
                    // Skip weekends
                    if (dayOfWeek === 0 || dayOfWeek === 6) return;

                    const dateStr = d.toISOString().split('T')[0];
                    const container = document.createElement('div');
                    container.className = 'date-checkbox';
                    container.onclick = function () { toggleDateCheckbox(this); };

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `date-${ts}`;
                    checkbox.value = ts;
                    checkbox.onclick = function (e) { e.stopPropagation(); this.closest('.date-checkbox').classList.toggle('selected', this.checked); };

                    const label = document.createElement('label');
                    label.htmlFor = `date-${ts}`;
                    label.textContent = dateStr;
                    label.onclick = function (e) { e.preventDefault(); };

                    container.appendChild(checkbox);
                    container.appendChild(label);
                    ui.dateCheckboxes.appendChild(container);
                });

                ui.calcBtn.disabled = false;
                ui.loadBtn.innerText = "1. Load Dates";
                ui.status.innerText = "Select dates, then click Calculate.";

            } catch (e) {
                showError(e.message);
                ui.loadBtn.innerText = "Retry";
            }
        }

        // Color palette for multiple overlays
        const COLORS = [
            '#00e676', '#ff7043', '#42a5f5', '#ab47bc', '#fdd835',
            '#26c6da', '#ec407a', '#66bb6a', '#ff8a65', '#7e57c2'
        ];

        // Process single date and return RND data
        async function processDate(ticker, date, currentPrice) {
            const res = await fetch(`${API_URL}/?ticker=${ticker}&date=${date}`);
            const json = await res.json();

            if (json.error) throw new Error(json.details);

            const result = json.optionChain.result[0];
            const calls = result.options[0].calls || [];
            const puts = result.options[0].puts || [];
            const spotPrice = result.quote.regularMarketPrice;

            // Build maps of call and put prices by strike
            const callMap = new Map();
            const putMap = new Map();

            const isValidOption = (opt) => {
                if ((!opt.volume || opt.volume < 1) && (!opt.openInterest || opt.openInterest < 5)) return false;
                if (!opt.bid || opt.bid < 0.01) return false;
                if (!opt.ask || opt.ask <= opt.bid) return false;
                const mid = (opt.bid + opt.ask) / 2;
                const spread = opt.ask - opt.bid;
                if (spread / mid > 0.8) return false;
                return true;
            };

            calls.forEach(c => {
                if (isValidOption(c)) callMap.set(c.strike, (c.bid + c.ask) / 2);
            });

            puts.forEach(p => {
                if (isValidOption(p)) putMap.set(p.strike, (p.bid + p.ask) / 2);
            });

            const allStrikes = [...new Set([...callMap.keys(), ...putMap.keys()])]
                .filter(k => {
                    const moneyness = k / spotPrice;
                    return moneyness >= 0.80 && moneyness <= 1.40;
                })
                .sort((a, b) => a - b);

            if (allStrikes.length < 10) throw new Error(`Not enough liquid options for ${new Date(date * 1000).toLocaleDateString()}`);

            const atmLow = spotPrice * 0.98;
            const atmHigh = spotPrice * 1.02;

            let data = allStrikes.map(strike => {
                const callPrice = callMap.get(strike);
                const putPrice = putMap.get(strike);
                let price;

                if (strike >= atmLow && strike <= atmHigh) {
                    if (callPrice !== undefined && putPrice !== undefined) {
                        const putAsCall = putPrice + spotPrice - strike;
                        price = (callPrice + putAsCall) / 2;
                    } else if (callPrice !== undefined) {
                        price = callPrice;
                    } else if (putPrice !== undefined) {
                        price = putPrice + spotPrice - strike;
                    } else {
                        return null;
                    }
                } else if (strike < spotPrice) {
                    if (putPrice !== undefined) {
                        price = putPrice + spotPrice - strike;
                    } else if (callPrice !== undefined) {
                        price = callPrice;
                    } else {
                        return null;
                    }
                } else {
                    if (callPrice !== undefined) {
                        price = callPrice;
                    } else if (putPrice !== undefined) {
                        price = putPrice + spotPrice - strike;
                    } else {
                        return null;
                    }
                }

                return { k: strike, p: Math.max(0.01, price) };
            }).filter(d => d !== null);

            data = removeOutliers(data, 'p', 2.5);
            if (data.length < 10) throw new Error(`Not enough data for ${new Date(date * 1000).toLocaleDateString()}`);

            const strikes = data.map(d => d.k);
            const prices = data.map(d => d.p);

            const numControlPoints = Math.min(25, Math.max(12, Math.floor(data.length / 3)));
            const spline = fitBSpline(strikes, prices, numControlPoints, 3);

            const minK = Math.min(...strikes);
            const maxK = Math.max(...strikes);
            const range = maxK - minK;
            const evalMin = minK - range * 0.05;
            const evalMax = maxK + range * 0.05;
            const numEvalPoints = 200;

            const evalStrikes = [];
            for (let i = 0; i < numEvalPoints; i++) {
                evalStrikes.push(evalMin + (evalMax - evalMin) * i / (numEvalPoints - 1));
            }

            let pdfY = bsplineSecondDerivative(spline, evalStrikes);
            const sigma = (maxK - minK) / 30;
            pdfY = gaussianSmooth(evalStrikes, pdfY, sigma);
            pdfY = pdfY.map(y => Math.max(0, y));

            let area = 0;
            for (let i = 1; i < evalStrikes.length; i++) {
                area += (pdfY[i] + pdfY[i - 1]) / 2 * (evalStrikes[i] - evalStrikes[i - 1]);
            }
            const finalPDF = area > 0 ? pdfY.map(y => y / area) : pdfY;

            return { evalStrikes, finalPDF, spotPrice, dateLabel: new Date(date * 1000).toLocaleDateString() };
        }

        async function calculateRND() {
            ui.calcBtn.innerText = "Calculating...";
            ui.chart.innerHTML = "";

            try {
                const ticker = ui.ticker.value;
                const checkedBoxes = document.querySelectorAll('.date-checkbox input:checked');
                const selectedDates = Array.from(checkedBoxes).map(cb => cb.value);

                if (selectedDates.length === 0) {
                    throw new Error("Please select at least one expiration date.");
                }

                ui.status.innerText = `Processing ${selectedDates.length} date(s)...`;

                // Process all selected dates in parallel
                const results = await Promise.all(
                    selectedDates.map((date, idx) => {
                        ui.status.innerText = `Fetching ${idx + 1}/${selectedDates.length}...`;
                        return processDate(ticker, date, null);
                    })
                );

                // Build traces for each date
                const traces = results.map((r, idx) => ({
                    x: r.evalStrikes,
                    y: r.finalPDF,
                    mode: 'lines',
                    fill: results.length === 1 ? 'tozeroy' : 'none',
                    line: { color: COLORS[idx % COLORS.length], width: 2.5 },
                    name: r.dateLabel
                }));

                // Find global max for spot line
                const globalMaxPDF = Math.max(...results.flatMap(r => r.finalPDF));
                const currentPrice = results[0].spotPrice;

                // Determine shared x-axis range from all data
                const allStrikes = results.flatMap(r => r.evalStrikes);
                const xMin = Math.min(...allStrikes);
                const xMax = Math.max(...allStrikes);

                const title = results.length === 1
                    ? `RND: ${ticker} (${results[0].dateLabel})`
                    : `RND Comparison: ${ticker} (${results.length} expirations)`;

                Plotly.newPlot('chart', traces, {
                    title: title,
                    paper_bgcolor: '#161616',
                    plot_bgcolor: '#161616',
                    font: { color: '#e0e0e0' },
                    xaxis: { title: 'Strike Price ($)', gridcolor: '#333', range: [xMin, xMax] },
                    yaxis: { title: 'Probability Density', gridcolor: '#333' },
                    shapes: [{
                        type: 'line',
                        x0: currentPrice, x1: currentPrice,
                        y0: 0, y1: globalMaxPDF,
                        line: { color: 'white', dash: 'dot', width: 1.5 }
                    }],
                    legend: {
                        x: 1, y: 1,
                        xanchor: 'right',
                        bgcolor: 'rgba(22,22,22,0.8)',
                        bordercolor: '#333',
                        borderwidth: 1
                    },
                    autosize: true,
                    margin: { l: 60, r: 30, t: 50, b: 50 }
                }, { responsive: true });

                ui.calcBtn.innerText = "2. Calculate PDF";
                ui.status.innerText = "";

            } catch (e) {
                showError(e.message);
                ui.calcBtn.innerText = "Retry";
            }
        }
    </script>

</body>

</html>