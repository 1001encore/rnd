<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RND Explorer</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --bg: #0a0a0a;
            --card: #161616;
            --text: #e0e0e0;
            --accent: #00e676;
            --err: #ff5252;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            padding: 20px;
            margin: 0;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        /* Header */
        h1 {
            margin-bottom: 5px;
            color: var(--accent);
        }

        p {
            color: #888;
            margin-bottom: 25px;
            font-size: 0.9rem;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            background: var(--card);
            padding: 15px;
            border-radius: 8px;
            flex-wrap: wrap;
            border: 1px solid #333;
        }

        input,
        select {
            padding: 10px;
            background: #222;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            flex-grow: 1;
            min-width: 120px;
        }

        button {
            padding: 10px 20px;
            background: var(--accent);
            color: black;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: opacity 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        /* Chart Area */
        .chart-wrapper {
            width: 100%;
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        #chart {
            width: 100%;
            max-width: 900px;
            height: 600px;
            background: var(--card);
            border-radius: 8px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .status {
            position: absolute;
            color: #666;
            font-size: 1.1rem;
        }

        .error {
            color: var(--err);
            background: rgba(255, 82, 82, 0.1);
            padding: 10px;
            border-radius: 4px;
            margin-top: 20px;
            display: none;
            border: 1px solid var(--err);
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>RND Explorer</h1>
        <p>Risk-Neutral Density Estimator (Pure JS + Cloudflare)</p>

        <div class="controls">
            <input type="text" id="ticker" value="SPY" placeholder="Ticker (e.g. SPY)">
            <button onclick="loadExpirations()" id="btn-load">1. Load Dates</button>
            <select id="expiry" disabled>
                <option>Select Date...</option>
            </select>
            <button onclick="calculateRND()" id="btn-calc" disabled>2. Calculate PDF</button>
        </div>

        <div id="error-box" class="error"></div>

        <div class="chart-wrapper">
            <div id="chart">
                <div class="status" id="status-text">Enter a ticker to begin</div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const API_URL = "https://rnd.1001encore.workers.dev";

        // --- MATH UTILS (Gaussian Kernel & Smoothing) ---
        function gaussianSmooth(x, y, sigma) {
            const smoothed = [];
            for (let i = 0; i < x.length; i++) {
                let num = 0, den = 0;
                for (let j = 0; j < x.length; j++) {
                    const w = Math.exp(-Math.pow(x[i] - x[j], 2) / (2 * sigma * sigma));
                    num += w * y[j];
                    den += w;
                }
                smoothed.push(num / den);
            }
            return smoothed;
        }

        // Multi-pass smoothing for better results
        function multiPassSmooth(x, y, sigma, passes = 3) {
            let result = y;
            for (let i = 0; i < passes; i++) {
                result = gaussianSmooth(x, result, sigma);
            }
            return result;
        }

        // Savitzky-Golay-like smoothing derivative (more stable)
        function smoothDerivative(x, y, windowSize = 5) {
            const d = [];
            const newX = [];
            const half = Math.floor(windowSize / 2);

            for (let i = half; i < x.length - half; i++) {
                // Linear regression over window to estimate slope
                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                let n = 0;
                for (let j = -half; j <= half; j++) {
                    const xi = x[i + j];
                    const yi = y[i + j];
                    sumX += xi;
                    sumY += yi;
                    sumXY += xi * yi;
                    sumX2 += xi * xi;
                    n++;
                }
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                d.push(slope);
                newX.push(x[i]);
            }
            return { x: newX, y: d };
        }

        function derivative(x, y) {
            const d = [];
            const newX = [];
            for (let i = 1; i < x.length - 1; i++) {
                d.push((y[i + 1] - y[i - 1]) / (x[i + 1] - x[i - 1]));
                newX.push(x[i]);
            }
            return { x: newX, y: d };
        }

        // Remove outliers using IQR method
        function removeOutliers(data, key, factor = 1.5) {
            const values = data.map(d => d[key]).sort((a, b) => a - b);
            const q1 = values[Math.floor(values.length * 0.25)];
            const q3 = values[Math.floor(values.length * 0.75)];
            const iqr = q3 - q1;
            const lower = q1 - factor * iqr;
            const upper = q3 + factor * iqr;
            return data.filter(d => d[key] >= lower && d[key] <= upper);
        }

        // Interpolate to uniform grid for better smoothing
        function interpolateToGrid(strikes, prices, numPoints = 100) {
            const minK = Math.min(...strikes);
            const maxK = Math.max(...strikes);
            const step = (maxK - minK) / (numPoints - 1);
            const newStrikes = [];
            const newPrices = [];

            for (let i = 0; i < numPoints; i++) {
                const k = minK + i * step;
                newStrikes.push(k);

                // Linear interpolation
                let j = 0;
                while (j < strikes.length - 1 && strikes[j + 1] < k) j++;

                if (j >= strikes.length - 1) {
                    newPrices.push(prices[prices.length - 1]);
                } else if (k <= strikes[0]) {
                    newPrices.push(prices[0]);
                } else {
                    const t = (k - strikes[j]) / (strikes[j + 1] - strikes[j]);
                    newPrices.push(prices[j] + t * (prices[j + 1] - prices[j]));
                }
            }
            return { strikes: newStrikes, prices: newPrices };
        }

        // --- UI LOGIC ---
        const ui = {
            ticker: document.getElementById("ticker"),
            loadBtn: document.getElementById("btn-load"),
            calcBtn: document.getElementById("btn-calc"),
            select: document.getElementById("expiry"),
            chart: document.getElementById("chart"),
            status: document.getElementById("status-text"),
            err: document.getElementById("error-box")
        };

        function showError(msg) {
            ui.err.style.display = 'block';
            ui.err.innerText = "Error: " + msg;
            ui.status.innerText = "";
        }

        async function loadExpirations() {
            ui.err.style.display = 'none';
            ui.loadBtn.innerText = "Loading...";

            try {
                const res = await fetch(`${API_URL}/?ticker=${ui.ticker.value}`);
                const data = await res.json();

                if (data.error) throw new Error(data.details || "API Error");
                if (!data.optionChain) throw new Error("No option data found");

                const dates = data.optionChain.result[0].expirationDates;
                ui.select.innerHTML = "";

                dates.forEach(ts => {
                    const d = new Date(ts * 1000);
                    const opt = document.createElement("option");
                    opt.value = ts;
                    opt.text = d.toISOString().split('T')[0];
                    ui.select.appendChild(opt);
                });

                ui.select.disabled = false;
                ui.calcBtn.disabled = false;
                ui.loadBtn.innerText = "1. Load Dates";
                ui.status.innerText = "Date Loaded. Click Calculate.";

            } catch (e) {
                showError(e.message);
                ui.loadBtn.innerText = "Retry";
            }
        }

        async function calculateRND() {
            ui.calcBtn.innerText = "Calculating...";
            ui.status.innerText = "Fetching Option Chain...";
            ui.chart.innerHTML = ""; // Clear chart

            try {
                const ticker = ui.ticker.value;
                const date = ui.select.value;

                // 1. Fetch Data
                const res = await fetch(`${API_URL}/?ticker=${ticker}&date=${date}`);
                const json = await res.json();

                if (json.error) throw new Error(json.details);

                const result = json.optionChain.result[0];
                const calls = result.options[0].calls;
                const currentPrice = result.quote.regularMarketPrice;

                // 2. Process Data with improved filtering
                // Filter for liquid, reasonable options
                let data = calls
                    .filter(c => {
                        // Must have volume and open interest
                        if (!c.volume || c.volume < 5) return false;
                        if (!c.openInterest || c.openInterest < 10) return false;

                        // Must have valid bid/ask
                        if (!c.bid || c.bid < 0.10) return false;
                        if (!c.ask || c.ask <= c.bid) return false;

                        // Bid-ask spread should be reasonable (< 50% of mid)
                        const mid = (c.bid + c.ask) / 2;
                        const spread = c.ask - c.bid;
                        if (spread / mid > 0.5) return false;

                        // Moneyness filter: focus on strikes within reasonable range
                        // Typically 70% to 130% of current price
                        const moneyness = c.strike / currentPrice;
                        if (moneyness < 0.70 || moneyness > 1.30) return false;

                        return true;
                    })
                    .map(c => ({
                        k: c.strike,
                        p: (c.bid + c.ask) / 2,
                        vol: c.volume,
                        oi: c.openInterest
                    }))
                    .sort((a, b) => a.k - b.k);

                // Remove price outliers
                data = removeOutliers(data, 'p', 2.0);

                if (data.length < 15) throw new Error("Not enough liquid options to calculate RND. Try a different expiration.");

                // Interpolate to uniform grid for stable derivatives
                const interpolated = interpolateToGrid(
                    data.map(d => d.k),
                    data.map(d => d.p),
                    150 // More points for smoother curve
                );

                const strikes = interpolated.strikes;
                const prices = interpolated.prices;

                // 3. Math (Multi-pass Smooth -> Smooth Derivative)
                // Adaptive bandwidth based on strike spacing
                const avgSpacing = (strikes[strikes.length - 1] - strikes[0]) / strikes.length;
                const sigma = Math.max(currentPrice * 0.025, avgSpacing * 4); // More aggressive smoothing

                // Multi-pass smoothing for very smooth price curve
                const smoothPrices = multiPassSmooth(strikes, prices, sigma, 3);

                // Use smooth derivative with larger window
                const d1 = smoothDerivative(strikes, smoothPrices, 7);

                // Smooth d1 before taking second derivative
                const smoothD1 = multiPassSmooth(d1.x, d1.y, sigma * 0.8, 2);
                const d2 = smoothDerivative(d1.x, smoothD1, 7); // PDF

                // Final smoothing pass on PDF
                let pdfY = multiPassSmooth(d2.x, d2.y, sigma * 0.5, 2);

                // Clip negatives and very small values
                pdfY = pdfY.map(y => Math.max(0, y));

                // Normalize PDF properly (integrate with trapezoid rule)
                let area = 0;
                for (let i = 1; i < d2.x.length; i++) {
                    area += (pdfY[i] + pdfY[i - 1]) / 2 * (d2.x[i] - d2.x[i - 1]);
                }
                const finalPDF = area > 0 ? pdfY.map(y => y / area) : pdfY;

                // 4. Plot
                Plotly.newPlot('chart', [{
                    x: d2.x, y: finalPDF,
                    mode: 'lines', fill: 'tozeroy',
                    line: { color: '#00e676', width: 3 },
                    name: 'Implied Probability'
                }], {
                    title: `RND: ${ticker} (${new Date(date * 1000).toLocaleDateString()})`,
                    paper_bgcolor: '#161616', plot_bgcolor: '#161616',
                    font: { color: '#e0e0e0' },
                    xaxis: { title: 'Strike Price ($)', gridcolor: '#333' },
                    yaxis: { title: 'Probability Density', gridcolor: '#333' },
                    shapes: [{ type: 'line', x0: currentPrice, x1: currentPrice, y0: 0, y1: Math.max(...finalPDF), line: { color: 'white', dash: 'dot' } }]
                }, { responsive: true });

                ui.calcBtn.innerText = "2. Calculate PDF";

            } catch (e) {
                showError(e.message);
                ui.calcBtn.innerText = "Retry";
            }
        }
    </script>

</body>

</html>