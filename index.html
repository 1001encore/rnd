<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RND Explorer</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --bg: #0a0a0a;
            --card: #161616;
            --text: #e0e0e0;
            --accent: #00e676;
            --err: #ff5252;
            --panel-width: 220px;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            padding: 0;
            margin: 0;
        }

        .app-layout {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .app-header {
            padding: 20px 20px 0 20px;
        }

        .main-area {
            display: flex;
            flex: 1;
            padding-top: 20px;
        }

        .content-area {
            flex: 1;
            padding: 0 20px 20px 20px;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        h1 {
            margin-bottom: 5px;
            color: var(--accent);
        }

        p {
            color: #888;
            margin-bottom: 25px;
            font-size: 0.9rem;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            background: var(--card);
            padding: 15px;
            border-radius: 8px;
            flex-wrap: wrap;
            border: 1px solid #333;
        }

        input,
        select {
            padding: 10px;
            background: #222;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            flex-grow: 1;
            min-width: 120px;
        }

        /* Date selector panel */

        .date-panel {
            background: var(--card);
            border: 1px solid #333;
            border-radius: 8px;
            width: var(--panel-width);
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
            margin-left: 20px;
            margin-bottom: 20px;
        }

        .date-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .date-panel-title {
            color: #ccc;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .date-actions {
            display: flex;
            gap: 4px;
        }

        .date-actions button {
            padding: 2px 6px;
            font-size: 0.65rem;
            background: #333;
            color: #aaa;
            border-radius: 3px;
            border: 1px solid #444;
            cursor: pointer;
            flex: 1;
        }

        .date-actions button:hover {
            background: #444;
            color: white;
            border-color: #555;
        }

        .date-checkboxes {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
            padding-right: 4px;
            max-height: 70vh;
            overflow-y: auto;
        }

        /* Custom Scrollbar for panel */
        .date-checkboxes::-webkit-scrollbar {
            width: 6px;
        }

        .date-checkboxes::-webkit-scrollbar-track {
            background: #111;
        }

        .date-checkboxes::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        .date-checkboxes::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        .date-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            cursor: pointer;
            transition: background 0.1s;
            font-size: 0.8rem;
            color: #aaa;
            border-radius: 4px;
        }

        .date-checkbox:hover {
            background: #222;
            color: #fff;
        }

        .date-checkbox.selected {
            background: rgba(0, 230, 118, 0.15);
            color: var(--accent);
            font-weight: 500;
        }

        .date-checkbox input {
            accent-color: var(--accent);
            width: 13px;
            height: 13px;
            cursor: pointer;
            margin: 0;
            flex-shrink: 0;
        }

        .date-checkbox label {
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .empty-state {
            color: #444;
            font-size: 0.8rem;
            text-align: center;
            margin-top: 20px;
            font-style: italic;
        }

        .date-checkbox label {
            cursor: pointer;
            user-select: none;
        }



        button {
            padding: 10px 20px;
            background: var(--accent);
            color: black;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: opacity 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        /* Chart Area */
        #chart {
            width: 100%;
            height: calc(100vh - 200px);
            /* Fill remaining height roughly */
            min-height: 500px;
            background: var(--card);
            margin-top: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            position: relative;
        }

        /* Center the status text before chart loads */
        #chart .status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Make Plotly chart fill the container */
        #chart .js-plotly-plot,
        #chart .plotly,
        #chart .plot-container {
            width: 100% !important;
            height: 100% !important;
        }

        .status {
            position: absolute;
            color: #666;
            font-size: 1.1rem;
        }

        .error {
            color: var(--err);
            background: rgba(255, 82, 82, 0.1);
            padding: 10px;
            border-radius: 4px;
            margin-top: 20px;
            display: none;
            border: 1px solid var(--err);
        }

        /* Explainer Accordion */
        .explainer {
            padding: 40px 20px 60px 20px;
        }

        .explainer-accordion {
            margin: 0 auto;
            background: var(--card);
            border: 1px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }

        .explainer-accordion summary {
            padding: 18px 20px;
            cursor: pointer;
            color: var(--accent);
            font-weight: 600;
            font-size: 1rem;
            list-style: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .explainer-accordion summary::-webkit-details-marker {
            display: none;
        }

        .explainer-accordion summary::after {
            content: '+';
            font-size: 1.3rem;
            color: #666;
            transition: transform 0.2s;
        }

        .explainer-accordion[open] summary::after {
            content: 'âˆ’';
        }

        .explainer-accordion summary:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .explainer-body {
            padding: 20px 30px 30px 30px;
            border-top: 1px solid #333;
        }

        .explainer-body h3 {
            color: #ccc;
            font-size: 1.05rem;
            margin: 25px 0 10px 0;
        }

        .explainer-body p {
            color: #888;
            font-size: 0.95rem;
            line-height: 1.8;
            margin: 0 0 15px 0;
        }

        .explainer-body .disclaimer {
            font-size: 0.85rem;
            color: #555;
            border-left: 2px solid #333;
            padding-left: 12px;
            margin-top: 25px;
        }
    </style>
</head>

<body>

    <div class="app-layout">
        <div class="app-header">
            <h1>Risk-Neutral Density (RND) Visualizer</h1>
        </div>

        <div class="main-area">
            <div id="date-panel" class="date-panel">
                <div class="date-panel-header">
                    <span class="date-panel-title">Expirations</span>
                    <div class="date-actions">
                        <button onclick="selectAllDates()" title="Select All">All</button>
                        <button onclick="clearAllDates()" title="Clear All">None</button>
                    </div>
                </div>
                <div id="date-checkboxes" class="date-checkboxes">
                    <div class="empty-state">Load dates first</div>
                </div>
            </div>

            <div class="content-area">
                <div class="controls">
                    <input type="text" id="ticker" value="SPY" placeholder="Ticker (e.g. SPY)">
                    <button onclick="loadExpirations()" id="btn-load">1. Load Dates</button>
                    <button onclick="calculateRND()" id="btn-calc" disabled>2. Calculate & Chart</button>
                </div>

                <div id="error-box" class="error"></div>

                <div id="chart">
                    <div class="status" id="status-text">Enter a ticker to begin</div>
                </div>
            </div>
        </div>
    </div>

    <footer class="explainer">
        <details class="explainer-accordion">
            <summary>What is This About?</summary>
            <div class="explainer-body">
                <h3>Why This Exists</h3>
                <p>
                    In financial markets, if you try to estimate how rare an event is using a normal distribution,
                    you'll be catastrophically wrong. Take the recent one day silver crash: a move of that
                    magnitude was roughly a 5-sigma event -- something that, under Gaussian assumptions, should happen
                    once every ~7 million trading days, or about 27,000 years. And yet it happened. So did the 1987
                    crash, the 2008 financial crisis, and the 2020 COVID drop. Returns are both
                    <strong>skewed</strong> (crashes happen faster than rallies) and <strong>fat-tailed</strong>
                    (extreme events occur far more often than a bell curve would predict).
                </p>
                <p>
                    One approach is to model fat tails historically, to capture the asset's charachteristics --
                    by measuring kurtosis from past returns (which assumes past returns are a good indicator of future
                    returns) and fitting
                    distributions like Student's t, (which involve guessing the parameters). But historical data is
                    backward-looking, regime-dependent, and
                    may not reflect <em>current</em> market expectations. What if a crisis is brewing that has no
                    historical example?
                </p>
                <p>
                    <strong>This tool takes a different approach:</strong> instead of modeling, we simply
                    <em>extract</em>
                    the probability distribution that the market is actively pricing in right now. Traders' collective
                    bets, expressed through option prices at every strike, implicitly define a probability distribution.
                    We recover that directly.
                </p>

                <h3>What This Shows (And What It Doesn't)</h3>
                <p>
                    <strong>The Risk-Neutral Density (RND) is the market's <strong>pricing</strong> -- not a
                        forecast.</strong>
                    It answers: "Given current option prices, what probability distribution is consistent with
                    no-arbitrage?"
                    This is fundamentally different from predicting where prices will actually go.
                </p>
                <p>
                    <strong>Why "risk-neutral" matters:</strong> In a world where investors were indifferent to risk,
                    the RND would equal actual probabilities. But investors are risk-averse: they pay extra for downside
                    protection (a phenomenon known as the equity risk premium, which appeared after aforementioned
                    crashes). A heavily left-skewed RND doesn't necessarily mean a crash is likely -- it may just mean
                    crash insurance is expensive.
                </p>
                <p>
                    <strong>What you can do with this:</strong> RND is useful for understanding market sentiment
                    and comparing implied expectations across expirations. Some traders use RNDs to construct
                    market-neutral portfolios -- if you believe the real-world distribution differs from the
                    risk-neutral one, that's a potential edge.
                </p>

                <h3>How It's Calculated</h3>
                <p>
                    The mathematical foundation is the <strong>Breeden-Litzenberger formula</strong> (1978): the
                    risk-neutral density equals the second derivative of call prices with respect to strike.
                    Intuitively,
                    the "curvature" of option prices across strikes encodes probability mass at each price level.
                </p>
                <p>
                    Real-time option data is fetched, filtered for liquid contracts, and puts are converted to
                    call-equivalent prices via put-call parity. A smooth B-spline curve is fitted to remove noise,
                    the second derivative is computed, and the result is normalized into a proper probability density.
                </p>

                <h3>Interesting Patterns</h3>
                <p>
                    <strong>Bimodal Shapes:</strong> Before binary events (earnings, FED decisions, elections), the RND
                    may show two distinct peaks -- the market is pricing two possible outcomes rather than a single
                    range.
                    The relative heights and positions reveal the market's implied scenario probabilities.
                </p>
                <p>
                    <strong>Contrarian Signals:</strong> When the RND's peak shifts heavily to the downside, it can
                    indicate that fear is already fully priced in -- and the market may be near a bottom. Conversely,
                    when the peak is stretched far to the upside with thin left tails, complacency may be setting in.
                    Extreme positioning in either direction often precedes a reversal, since the options market tends
                    to overshoot when sentiment is at its most one-sided.
                </p>
            </div>
        </details>
    </footer>

    <script>
        // --- CONFIGURATION ---
        const API_URL = "https://rnd.1001encore.workers.dev";

        // --- MATH UTILS (B-Spline Smoothing) ---

        // Cubic B-spline basis function
        function bsplineBasis(i, k, t, knots) {
            if (k === 0) {
                return (t >= knots[i] && t < knots[i + 1]) ? 1 : 0;
            }

            let left = 0, right = 0;
            const denom1 = knots[i + k] - knots[i];
            const denom2 = knots[i + k + 1] - knots[i + 1];

            if (denom1 !== 0) {
                left = ((t - knots[i]) / denom1) * bsplineBasis(i, k - 1, t, knots);
            }
            if (denom2 !== 0) {
                right = ((knots[i + k + 1] - t) / denom2) * bsplineBasis(i + 1, k - 1, t, knots);
            }

            return left + right;
        }

        // Generate uniform knots for B-spline
        function generateKnots(n, degree) {
            const knots = [];
            const m = n + degree + 1;
            for (let i = 0; i < m; i++) {
                if (i <= degree) {
                    knots.push(0);
                } else if (i >= m - degree - 1) {
                    knots.push(1);
                } else {
                    knots.push((i - degree) / (n - degree));
                }
            }
            return knots;
        }

        // Fit B-spline to data points using least squares
        function fitBSpline(x, y, numControlPoints = 20, degree = 3) {
            const n = numControlPoints;
            const minX = Math.min(...x);
            const maxX = Math.max(...x);

            // Normalize x to [0, 1]
            const tValues = x.map(xi => (xi - minX) / (maxX - minX));

            const knots = generateKnots(n, degree);

            // Build basis matrix
            const B = [];
            for (let j = 0; j < x.length; j++) {
                const row = [];
                const t = Math.min(0.9999, Math.max(0, tValues[j])); // Clamp to avoid boundary issues
                for (let i = 0; i < n; i++) {
                    row.push(bsplineBasis(i, degree, t, knots));
                }
                B.push(row);
            }

            // Solve least squares: (B^T B) c = B^T y
            // Using simple pseudo-inverse approximation
            const BtB = [];
            const Bty = [];

            for (let i = 0; i < n; i++) {
                BtB.push(new Array(n).fill(0));
                Bty.push(0);
                for (let j = 0; j < x.length; j++) {
                    Bty[i] += B[j][i] * y[j];
                    for (let k = 0; k < n; k++) {
                        BtB[i][k] += B[j][i] * B[j][k];
                    }
                }
                // Add regularization to avoid singular matrix
                BtB[i][i] += 0.001;
            }

            // Solve using Gauss-Seidel iteration
            const controlPoints = new Array(n).fill(0);
            for (let iter = 0; iter < 100; iter++) {
                for (let i = 0; i < n; i++) {
                    let sum = Bty[i];
                    for (let j = 0; j < n; j++) {
                        if (i !== j) sum -= BtB[i][j] * controlPoints[j];
                    }
                    controlPoints[i] = sum / BtB[i][i];
                }
            }

            return { controlPoints, knots, degree, minX, maxX };
        }

        // Evaluate B-spline at given x values
        function evaluateBSpline(spline, xValues) {
            const { controlPoints, knots, degree, minX, maxX } = spline;
            const n = controlPoints.length;

            return xValues.map(x => {
                // Normalize and clamp
                let t = (x - minX) / (maxX - minX);
                t = Math.min(0.9999, Math.max(0.0001, t));

                let val = 0;
                for (let i = 0; i < n; i++) {
                    val += controlPoints[i] * bsplineBasis(i, degree, t, knots);
                }
                return val;
            });
        }

        // Compute second derivative of B-spline (for RND)
        function bsplineSecondDerivative(spline, xValues, h = null) {
            const { minX, maxX } = spline;
            if (h === null) {
                h = (maxX - minX) / 500; // Small step for numerical derivative
            }

            return xValues.map(x => {
                const yMinus = evaluateBSpline(spline, [x - h])[0];
                const yCenter = evaluateBSpline(spline, [x])[0];
                const yPlus = evaluateBSpline(spline, [x + h])[0];
                return (yPlus - 2 * yCenter + yMinus) / (h * h);
            });
        }

        // Remove outliers using IQR method
        function removeOutliers(data, key, factor = 1.5) {
            const values = data.map(d => d[key]).sort((a, b) => a - b);
            const q1 = values[Math.floor(values.length * 0.25)];
            const q3 = values[Math.floor(values.length * 0.75)];
            const iqr = q3 - q1;
            const lower = q1 - factor * iqr;
            const upper = q3 + factor * iqr;
            return data.filter(d => d[key] >= lower && d[key] <= upper);
        }

        // Gaussian smoothing for final PDF polish
        function gaussianSmooth(x, y, sigma) {
            const smoothed = [];
            for (let i = 0; i < x.length; i++) {
                let num = 0, den = 0;
                for (let j = 0; j < x.length; j++) {
                    const w = Math.exp(-Math.pow(x[i] - x[j], 2) / (2 * sigma * sigma));
                    num += w * y[j];
                    den += w;
                }
                smoothed.push(num / den);
            }
            return smoothed;
        }

        // --- UI LOGIC ---
        const ui = {
            ticker: document.getElementById("ticker"),
            loadBtn: document.getElementById("btn-load"),
            calcBtn: document.getElementById("btn-calc"),
            chart: document.getElementById("chart"),
            status: document.getElementById("status-text"),
            err: document.getElementById("error-box"),
            datePanel: document.getElementById("date-panel"),
            dateCheckboxes: document.getElementById("date-checkboxes")
        };

        function showError(msg) {
            ui.err.style.display = 'block';
            ui.err.innerText = "Error: " + msg;
            ui.status.innerText = "";
        }

        function toggleDateCheckbox(container) {
            const checkbox = container.querySelector('input');
            checkbox.checked = !checkbox.checked;
            container.classList.toggle('selected', checkbox.checked);
        }

        function selectAllDates() {
            document.querySelectorAll('.date-checkbox input').forEach(cb => {
                cb.checked = true;
                cb.closest('.date-checkbox').classList.add('selected');
            });
        }

        function clearAllDates() {
            document.querySelectorAll('.date-checkbox input').forEach(cb => {
                cb.checked = false;
                cb.closest('.date-checkbox').classList.remove('selected');
            });
        }

        async function loadExpirations() {
            ui.err.style.display = 'none';
            ui.loadBtn.innerText = "Loading...";

            try {
                const res = await fetch(`${API_URL}/?ticker=${ui.ticker.value}`);
                const data = await res.json();

                if (data.error) throw new Error(data.details || "API Error");
                if (!data.optionChain) throw new Error("No option data found");

                const dates = data.optionChain.result[0].expirationDates;
                ui.dateCheckboxes.innerHTML = "";

                dates.forEach(ts => {
                    const d = new Date(ts * 1000);
                    const dayOfWeek = d.getDay();
                    // Skip weekends
                    if (dayOfWeek === 0 || dayOfWeek === 6) return;

                    const dateStr = d.toISOString().split('T')[0];
                    const container = document.createElement('div');
                    container.className = 'date-checkbox';
                    container.onclick = function () { toggleDateCheckbox(this); };

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `date-${ts}`;
                    checkbox.value = ts;
                    checkbox.onclick = function (e) { e.stopPropagation(); this.closest('.date-checkbox').classList.toggle('selected', this.checked); };

                    const label = document.createElement('label');
                    label.htmlFor = `date-${ts}`;
                    label.textContent = dateStr;
                    label.onclick = function (e) { e.preventDefault(); };

                    container.appendChild(checkbox);
                    container.appendChild(label);
                    ui.dateCheckboxes.appendChild(container);
                });

                ui.calcBtn.disabled = false;
                ui.loadBtn.innerText = "1. Load Dates";
                ui.status.innerText = "Select dates, then click Calculate.";

            } catch (e) {
                showError(e.message);
                ui.loadBtn.innerText = "Retry";
            }
        }

        // Color palette for multiple overlays
        const COLORS = [
            '#00e676', '#ff7043', '#42a5f5', '#ab47bc', '#fdd835',
            '#26c6da', '#ec407a', '#66bb6a', '#ff8a65', '#7e57c2'
        ];

        // Process single date and return RND data
        async function processDate(ticker, date, currentPrice) {
            const res = await fetch(`${API_URL}/?ticker=${ticker}&date=${date}`);
            const json = await res.json();

            if (json.error) throw new Error(json.details);

            const result = json.optionChain.result[0];
            const calls = result.options[0].calls || [];
            const puts = result.options[0].puts || [];
            const spotPrice = result.quote.regularMarketPrice;

            // Build maps of call and put prices by strike
            const callMap = new Map();
            const putMap = new Map();

            // Helper to get price: preference for Mid, fallback to Last
            const getPrice = (opt) => {
                if (opt.bid && opt.bid > 0 && opt.ask && opt.ask > opt.bid) {
                    return (opt.bid + opt.ask) / 2;
                }
                return opt.lastPrice;
            };

            const isValidOption = (opt) => {
                if ((!opt.volume || opt.volume < 1) && (!opt.openInterest || opt.openInterest < 5)) return false;

                // Check if we have valid quotes
                if (opt.bid && opt.bid > 0 && opt.ask && opt.ask > opt.bid) {
                    const mid = (opt.bid + opt.ask) / 2;
                    const spread = opt.ask - opt.bid;
                    if (spread / mid > 0.8) return false;
                    return true;
                }

                // Fallback for holidays/market close: use Last Price if available
                if (opt.lastPrice && opt.lastPrice > 0) {
                    return true;
                }

                return false;
            };

            calls.forEach(c => {
                if (isValidOption(c)) callMap.set(c.strike, getPrice(c));
            });

            puts.forEach(p => {
                if (isValidOption(p)) putMap.set(p.strike, getPrice(p));
            });

            const allStrikes = [...new Set([...callMap.keys(), ...putMap.keys()])]
                .filter(k => {
                    const moneyness = k / spotPrice;
                    return moneyness >= 0.80 && moneyness <= 1.40;
                })
                .sort((a, b) => a - b);

            if (allStrikes.length < 10) throw new Error(`Not enough liquid options for ${new Date(date * 1000).toLocaleDateString()}`);

            const atmLow = spotPrice * 0.98;
            const atmHigh = spotPrice * 1.02;

            let data = allStrikes.map(strike => {
                const callPrice = callMap.get(strike);
                const putPrice = putMap.get(strike);
                let price;

                if (strike >= atmLow && strike <= atmHigh) {
                    if (callPrice !== undefined && putPrice !== undefined) {
                        const putAsCall = putPrice + spotPrice - strike;
                        price = (callPrice + putAsCall) / 2;
                    } else if (callPrice !== undefined) {
                        price = callPrice;
                    } else if (putPrice !== undefined) {
                        price = putPrice + spotPrice - strike;
                    } else {
                        return null;
                    }
                } else if (strike < spotPrice) {
                    if (putPrice !== undefined) {
                        price = putPrice + spotPrice - strike;
                    } else if (callPrice !== undefined) {
                        price = callPrice;
                    } else {
                        return null;
                    }
                } else {
                    if (callPrice !== undefined) {
                        price = callPrice;
                    } else if (putPrice !== undefined) {
                        price = putPrice + spotPrice - strike;
                    } else {
                        return null;
                    }
                }

                return { k: strike, p: Math.max(0.01, price) };
            }).filter(d => d !== null);

            data = removeOutliers(data, 'p', 2.5);
            if (data.length < 10) throw new Error(`Not enough data for ${new Date(date * 1000).toLocaleDateString()}`);

            const strikes = data.map(d => d.k);
            const prices = data.map(d => d.p);

            const numControlPoints = Math.min(25, Math.max(12, Math.floor(data.length / 3)));
            const spline = fitBSpline(strikes, prices, numControlPoints, 3);

            const minK = Math.min(...strikes);
            const maxK = Math.max(...strikes);
            const range = maxK - minK;
            const evalMin = minK - range * 0.05;
            const evalMax = maxK + range * 0.05;
            const numEvalPoints = 200;

            const evalStrikes = [];
            for (let i = 0; i < numEvalPoints; i++) {
                evalStrikes.push(evalMin + (evalMax - evalMin) * i / (numEvalPoints - 1));
            }

            let pdfY = bsplineSecondDerivative(spline, evalStrikes);
            const sigma = (maxK - minK) / 30;
            pdfY = gaussianSmooth(evalStrikes, pdfY, sigma);
            pdfY = pdfY.map(y => Math.max(0, y));

            let area = 0;
            for (let i = 1; i < evalStrikes.length; i++) {
                area += (pdfY[i] + pdfY[i - 1]) / 2 * (evalStrikes[i] - evalStrikes[i - 1]);
            }
            const finalPDF = area > 0 ? pdfY.map(y => y / area) : pdfY;

            return { evalStrikes, finalPDF, spotPrice, dateLabel: new Date(date * 1000).toLocaleDateString() };
        }

        async function calculateRND() {
            ui.calcBtn.innerText = "Calculating...";
            ui.chart.innerHTML = "";

            try {
                const ticker = ui.ticker.value;
                const checkedBoxes = document.querySelectorAll('.date-checkbox input:checked');
                const selectedDates = Array.from(checkedBoxes).map(cb => cb.value);

                if (selectedDates.length === 0) {
                    throw new Error("Please select at least one expiration date.");
                }

                ui.status.innerText = `Processing ${selectedDates.length} date(s)...`;

                // Process all selected dates in parallel
                const results = await Promise.all(
                    selectedDates.map((date, idx) => {
                        ui.status.innerText = `Fetching ${idx + 1}/${selectedDates.length}...`;
                        return processDate(ticker, date, null);
                    })
                );

                // Build traces for each date
                const traces = results.map((r, idx) => ({
                    x: r.evalStrikes,
                    y: r.finalPDF,
                    mode: 'lines',
                    fill: results.length === 1 ? 'tozeroy' : 'none',
                    line: { color: COLORS[idx % COLORS.length], width: 2.5 },
                    name: r.dateLabel
                }));

                // Find global max for spot line
                const globalMaxPDF = Math.max(...results.flatMap(r => r.finalPDF));
                const currentPrice = results[0].spotPrice;

                // Determine shared x-axis range from all data
                const allStrikes = results.flatMap(r => r.evalStrikes);
                const xMin = Math.min(...allStrikes);
                const xMax = Math.max(...allStrikes);

                const title = results.length === 1
                    ? `RND: ${ticker} (${results[0].dateLabel})`
                    : `RND Comparison: ${ticker} (${results.length} expirations)`;

                Plotly.newPlot('chart', traces, {
                    title: title,
                    paper_bgcolor: '#161616',
                    plot_bgcolor: '#161616',
                    font: { color: '#e0e0e0' },
                    xaxis: { title: 'Strike Price ($)', gridcolor: '#333', range: [xMin, xMax] },
                    yaxis: { title: 'Probability Density', gridcolor: '#333' },
                    shapes: [{
                        type: 'line',
                        x0: currentPrice, x1: currentPrice,
                        y0: 0, y1: globalMaxPDF,
                        line: { color: 'white', dash: 'dot', width: 1.5 }
                    }],
                    legend: {
                        x: 1, y: 1,
                        xanchor: 'right',
                        bgcolor: 'rgba(22,22,22,0.8)',
                        bordercolor: '#333',
                        borderwidth: 1
                    },
                    autosize: true,
                    margin: { l: 60, r: 30, t: 50, b: 50 }
                }, { responsive: true });

                ui.calcBtn.innerText = "2. Calculate & Chart";
                ui.status.innerText = "";

            } catch (e) {
                showError(e.message);
                ui.calcBtn.innerText = "Retry";
            }
        }
    </script>

</body>

</html>